<!doctype html>
<!--
  DADOS & RISAS - Dice Roll Overlay
  ==================================
  OBS Browser Source overlay for displaying animated dice roll results.

  Setup:
  - Add as Browser Source in OBS (1920×1080)
  - Enable "Shutdown source when not visible" = OFF
  - Enable "Refresh browser when scene becomes active" = ON
  - Canvas body background must be transparent in OBS settings

  Behavior:
  - Listens for 'dice_rolled' events from Socket.io server
  - Displays result with elastic bounce animation (anime.js)
  - Shows character portrait (photo or initials fallback)
  - Auto-hides after 4s (6s for crits)
  - Shows critical hits (nat 20) with cyan screen flash + larger number
  - Shows fails (nat 1) with red screen flash + shake animation
  - Clears previous timers to handle rapid consecutive rolls

  Dependencies:
  - anime.js 3.2.1 (animation engine)
  - Socket.io 4.8.3 (real-time client)
  - overlay-dice.css (external stylesheet)
-->
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=1920, height=1080" />
    <title>DADOS & RISAS - Dice Overlay</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="overlay-dice.css" />
  </head>
  <body>
    <!-- Full-canvas flash for crit/fail — sits behind the dice card -->
    <div id="flash-overlay"></div>

    <!--
      Dice Roll Card Container
      Initially hidden (display: none), shown via anime.js when dice_rolled event fires.
      Positioned bottom-center via CSS.
    -->
    <div id="dice-container">
      <div class="dice-card">
        <!-- Character portrait (photo or initials) -->
        <div class="dice-avatar" id="dice-avatar">
          <span class="dice-avatar-initials" id="dice-avatar-initials">?</span>
        </div>

        <!-- Character name who rolled the dice -->
        <div class="dice-character" id="char-name">—</div>

        <!-- Dice type (d20, d6, etc.) -->
        <div class="dice-formula" id="dice-formula">d20</div>

        <!-- Roll breakdown showing base roll + modifier (e.g., "18 + 2") -->
        <div class="dice-breakdown" id="dice-breakdown">—</div>

        <!-- Large animated number showing final roll result -->
        <div class="dice-result" id="dice-result">—</div>

        <!-- Context label (¡CRÍTICO! / ¡PIFIA! / Total: N) -->
        <div class="dice-label" id="dice-label">—</div>
      </div>
    </div>

    <!-- External Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha384-fXdIufVbE9aU7STmdk/DWK0imNOozId9fTwzM/gi0NfPjphEIC3gq0M760UnsKVy" crossorigin="anonymous"></script>
    <script src="https://cdn.socket.io/4.8.3/socket.io.min.js" integrity="sha384-kzavj5fiMwLKzzD1f8S7TeoVIEi7uKHvbTA3ueZkrzYq75pNQUiUi6Dy98Q3fxb0" crossorigin="anonymous"></script>

    <script>
      // ═══════════════════════════════════════════════════════════════════════
      // Dice Overlay Logic
      // ═══════════════════════════════════════════════════════════════════════

      /**
       * Socket.io connection to the server.
       * Configure via `server` query parameter:
       *   overlay-dice.html?server=http://192.168.1.83:3000
       * Falls back to http://localhost:3000.
       */
      const serverUrl = new URLSearchParams(window.location.search).get("server") || "http://localhost:3000";
      const socket = io(serverUrl);

      // ───────────────────────────────────────────────────────────────────────
      // DOM Element References
      // ───────────────────────────────────────────────────────────────────────

      const container    = document.getElementById("dice-container");
      const flashOverlay = document.getElementById("flash-overlay");
      const charName     = document.getElementById("char-name");
      const diceFormula  = document.getElementById("dice-formula");
      const diceResult   = document.getElementById("dice-result");
      const diceLabel    = document.getElementById("dice-label");
      const diceAvatar   = document.getElementById("dice-avatar");
      const avatarInitials = document.getElementById("dice-avatar-initials");

      // ───────────────────────────────────────────────────────────────────────
      // State
      // ───────────────────────────────────────────────────────────────────────

      /** Timer reference for auto-hide */
      let hideTimer = null;

      /** Local character map — populated from initialData for photo lookups */
      const characterMap = {};

      // ───────────────────────────────────────────────────────────────────────
      // Utility Functions
      // ───────────────────────────────────────────────────────────────────────

      function getInitials(name) {
        return (name || "?")
          .split(" ")
          .map((w) => w[0] || "")
          .join("")
          .toUpperCase()
          .slice(0, 2);
      }

      /**
       * Updates the avatar circle with character photo or initials fallback.
       * Photo path from server is relative ("/assets/img/..."), prefixed with serverUrl.
       */
      function updateDiceAvatar(data) {
        const char = characterMap[data.charId];
        const photoUrl = char && char.photo ? serverUrl + char.photo : null;

        // Clear previous img
        const existingImg = diceAvatar.querySelector("img");
        if (existingImg) existingImg.remove();

        if (photoUrl) {
          avatarInitials.style.display = "none";
          const img = document.createElement("img");
          img.src = photoUrl;
          img.alt = data.characterName || "";
          img.onerror = () => {
            img.remove();
            avatarInitials.style.display = "";
            avatarInitials.textContent = getInitials(data.characterName);
          };
          diceAvatar.appendChild(img);
        } else {
          avatarInitials.style.display = "";
          avatarInitials.textContent = getInitials(data.characterName);
        }
      }

      /**
       * Triggers a brief full-canvas color flash (for crits and fails).
       * Uses anime.js to fade the flash overlay in and immediately back out.
       */
      function triggerFlash(color) {
        flashOverlay.style.background = color;
        anime({
          targets: flashOverlay,
          opacity: [0, 0.75, 0],
          duration: 450,
          easing: "easeInOutQuad",
        });
      }

      /**
       * Shakes the dice container horizontally (for fails).
       * Classic "error" shake pattern.
       */
      function triggerShake() {
        anime({
          targets: container,
          translateX: [0, -14, 14, -9, 9, -5, 5, 0],
          duration: 520,
          easing: "easeInOutSine",
        });
      }

      // ───────────────────────────────────────────────────────────────────────
      // Core Display Function
      // ───────────────────────────────────────────────────────────────────────

      /**
       * Displays an animated dice roll result.
       *
       * Animation Timeline:
       * 1. Cancel any pending auto-hide timer
       * 2. Update avatar, populate card content, apply crit/fail classes
       * 3. Trigger screen flash (crit = cyan, fail = red)
       * 4. Fade in card from bottom (500ms)
       * 5. Elastic bounce the result number (600-800ms, 100ms delay)
       * 6. Auto-hide after hideDelay (4s normal, 6s crit)
       *
       * @param {Object} data - Roll data from server
       * @param {string} data.charId - Character ID (for photo lookup)
       * @param {string} data.characterName - Name of character who rolled
       * @param {number} data.result - Base die result (before modifier)
       * @param {number} data.modifier - Modifier applied to roll
       * @param {number} data.rollResult - Final result (result + modifier)
       * @param {number} data.sides - Number of sides on the die
       */
      function showRoll(data) {
        if (hideTimer) clearTimeout(hideTimer);

        // ─── Update Avatar ────────────────────────────────────────────────
        updateDiceAvatar(data);

        // ─── Populate Card Content ────────────────────────────────────────
        charName.textContent = data.characterName || "Unknown";
        diceFormula.textContent = `d${data.sides ?? "?"}`;
        diceResult.textContent = data.rollResult;

        // Roll breakdown (e.g. "18 + 2", "5 - 1", or just "14")
        const breakdownEl = document.getElementById("dice-breakdown");
        if (data.modifier > 0) {
          breakdownEl.textContent = `${data.result} + ${data.modifier}`;
        } else if (data.modifier < 0) {
          breakdownEl.textContent = `${data.result} − ${Math.abs(data.modifier)}`;
        } else {
          breakdownEl.textContent = `${data.result}`;
        }

        // ─── Crit / Fail Detection ────────────────────────────────────────
        diceResult.className = "dice-result";
        diceLabel.className = "dice-label";
        container.classList.remove("is-crit", "is-fail");

        let hideDelay = 4000;
        let isCrit = false;

        if (data.result === 20 && data.sides === 20) {
          diceResult.classList.add("crit");
          diceLabel.classList.add("crit");
          diceLabel.textContent = "¡CRÍTICO!";
          container.classList.add("is-crit");
          triggerFlash("rgba(0, 212, 232, 0.45)");
          hideDelay = 6000;
          isCrit = true;
        } else if (data.result === 1 && data.sides === 20) {
          diceResult.classList.add("fail");
          diceLabel.classList.add("fail");
          diceLabel.textContent = "¡PIFIA!";
          container.classList.add("is-fail");
          triggerFlash("rgba(255, 77, 106, 0.45)");
          triggerShake();
          hideDelay = 4000;
        } else {
          diceLabel.textContent = `Total: ${data.rollResult}`;
        }

        // ─── Show Animation ───────────────────────────────────────────────
        container.style.display = "block";
        anime.set(container, { opacity: 0, translateY: 40, translateX: 0 });

        anime({
          targets: container,
          opacity: [0, 1],
          translateY: [40, 0],
          duration: 500,
          easing: "easeInOutQuad",
        });

        // Elastic bounce on the result number (slightly delayed for stagger)
        setTimeout(() => {
          anime({
            targets: diceResult,
            opacity: [0, 1],
            scale: isCrit ? [0.2, 1.45, 1] : [0.3, 1.15, 1],
            duration: isCrit ? 800 : 600,
            easing: "easeOutElastic(1, .5)",
          });
        }, 100);

        // ─── Auto-Hide Timer ──────────────────────────────────────────────
        hideTimer = setTimeout(() => {
          anime({
            targets: container,
            opacity: [1, 0],
            translateY: [0, -20],
            duration: 500,
            easing: "easeInOutQuad",
            complete: () => {
              container.style.display = "none";
              container.classList.remove("is-crit", "is-fail");
            },
          });
        }, hideDelay);
      }

      // ───────────────────────────────────────────────────────────────────────
      // Socket.io Event Handlers
      // ───────────────────────────────────────────────────────────────────────

      /** Bootstrap character map for photo lookups */
      socket.on("initialData", (data) => {
        data.characters.forEach((c) => { characterMap[c.id] = c; });
        console.log("Dice overlay: character map loaded", Object.keys(characterMap));
      });

      /** Keep character map fresh if photos or data change */
      socket.on("character_updated", (data) => {
        characterMap[data.character.id] = data.character;
      });

      /** Main dice roll handler */
      socket.on("dice_rolled", (data) => {
        console.log("Dice rolled:", data);
        showRoll(data);
      });

      socket.on("connect", () => console.log("Dice overlay connected"));
      socket.on("connect_error", (e) => console.error("Connection error:", e));
    </script>
  </body>
</html>
